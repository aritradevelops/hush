import fs from 'fs';
import path from 'path';
import minify from 'pg-minify';
import { camelToPascal, kebabToPascal, snakeToCamel } from '../../src/utils/string';

const QUERY_DIR = path.join('./', 'queries');
const OUTPUT_DIR = path.join('./', 'src', 'queries');

/**
 * Initializes the queries directory by clearing old queries and creating an empty structure.
 */
function initializeQueryDirectory() {
  try {
    if (fs.existsSync(OUTPUT_DIR)) {
      fs.rmSync(OUTPUT_DIR, { recursive: true, force: true });
    }
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    console.log("✅ Queries directory re-initialized.");
  } catch (error) {
    console.error("❌ Error initializing queries directory:", error);
  }
}

/**
 * Generates TypeScript query classes from SQL files.
 */
export function generateQuery() {
  try {
    initializeQueryDirectory();

    // Read all subdirectories in the queries directory
    const queryDirs = fs.readdirSync(QUERY_DIR, { withFileTypes: true }).filter(dir => dir.isDirectory());

    for (const dir of queryDirs) {
      const queryClass = new QueryClassGenerator(kebabToPascal(dir.name));
      const dirPath = path.join(QUERY_DIR, dir.name);

      // Read SQL files in each directory
      const queryFiles = fs.readdirSync(dirPath, { withFileTypes: true }).filter(file => file.isFile());

      for (const file of queryFiles) {
        const filePath = path.join(dirPath, file.name);
        const queryContent = fs.readFileSync(filePath, 'utf8');

        const parser = new QueryParser(queryContent, filePath);
        const functionName = snakeToCamel(file.name.replace('.sql', ''));

        queryClass.addQuery(functionName, parser.sql, parser.docString);
      }

      // Ensure output directory exists
      if (!fs.existsSync(OUTPUT_DIR)) {
        fs.mkdirSync(OUTPUT_DIR, { recursive: true });
      }

      // Write generated TypeScript class to file
      const outputFilePath = path.join(OUTPUT_DIR, `${dir.name}.query.ts`);
      fs.writeFileSync(outputFilePath, queryClass.generate());
      console.log(`✅ Successfully generated: ${outputFilePath}`);
    }
  } catch (error) {
    console.error("❌ Error generating queries:", error);
  }
}

/**
 * Class to generate TypeScript classes for queries.
 */
class QueryClassGenerator {
  private functions: [string, string, string][] = [];

  constructor(private moduleName: string) { }

  /**
   * Adds a query function to the class.
   * @param name - Function name
   * @param sql - Minified SQL string
   * @param docString - JSDoc string
   */
  addQuery(name: string, sql: string, docString: string) {
    this.functions.push([name, sql, docString]);
  }

  /**
   * Generates a TypeScript class with query functions.
   */
  generate(): string {
    return `/**
 * ⚠️ This file is auto-generated with \`npm run cli g:query\`
 * Do NOT edit this file manually. Changes will be overwritten.
 */
export class ${this.moduleName}Query {
${this.functions.map(e => this.generateFunction(...e)).join('\n\n')}
}
export default new ${this.moduleName}Query();`;
  }

  /**
   * Generates a TypeScript function for a query.
   */
  private generateFunction(name: string, sql: string, docString: string): string {
    return `${docString}
  ${name}() {
    return \`${sql}\`;
  }`;
  }
}

/**
 * Class to parse SQL queries and extract metadata.
 */
class QueryParser {
  constructor(private query: string, private filePath: string) { }

  /**
   * Extracts the SQL query, removes comments, and minifies it.
   */
  get sql(): string {
    try {
      const rawSql = this.query.split('*/').pop()?.trim();
      if (!rawSql) throw new Error("Invalid SQL format");
      return minify(rawSql);
    } catch (error) {
      console.error("❌ Error parsing SQL:", error, { filePath: this.filePath });
      return "";
    }
  }

  /**
   * Extracts and formats the JSDoc comment from the query.
   */
  get docString(): string {
    try {
      const docMatch = this.query.match(/\/\*([\s\S]*?)\*\//);
      if (!docMatch) return `  /**
   * No documentation provided.
   */`;

      const docContent = docMatch[1].trim();
      return `  /**
   * ${docContent.split('\n').map(line => line.trim()).join('\n   * ')}
   */`;
    } catch (error) {
      console.error("❌ Error extracting documentation:", error, { filePath: this.filePath });
      return `  /**
   * Error extracting documentation.
   */`;
    }
  }
}
